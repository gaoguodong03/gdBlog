---
title: LeeCode移动零
date: 2025-10-14
tags:
  - LeetCode
  - 双指针
categories: 果冻的LeetCode刷题
cover: ./img/logoLeetCode.jpg
---
[[../../note/Template/LeetCode|LeetCode]]
## 原题链接
https://leetcode.cn/problems/move-zeroes/solutions/489622/yi-dong-ling-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked

## 题目

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

**输入:** nums = `[0,1,0,3,12]`
**输出:** `[1,3,12,0,0]`

**示例 2:**

**输入:** nums = `[0]`
**输出:** `[0]`

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

**进阶：**你能尽量减少完成的操作次数吗？
## 题解

## 方法一：双指针
思路及解法

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

左指针左边均为非零数；

右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

```python
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size(), left = 0, right = 0;
        while (right < n) {
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
            right++;
        }
    }
};

```

## 方法二：python的库
```python
class Solution(object):

def moveZeroes(self, nums):

"""

:type nums: List[int]

:rtype: None Do not return anything, modify nums in-place instead.

"""

# 统计0的个数

zero_count = nums.count(0)

# 移除所有0

nums[:] = [num for num in nums if num != 0]

# 在列表末尾添加0

nums.extend([0] * zero_count)
```