<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>智能体四模块现状 | 果冻小配方</title><meta name="author" content="GuoDong"><meta name="copyright" content="GuoDong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 记忆 (Memory): 从被动存储到主动学习智能体的记忆模块负责信息的持久化存储和高效检索，解决了大型语言模型（LLM）本身“无状态”、“健忘”的核心问题。  早期状态 (2023-2024): 主要依赖RAG (Retrieval-Augmented Generation)。通过将外部知识（文档、数据库）转换为向量，并存储在向量数据库（如Pinecone, Chroma）中。当用户提问时">
<meta property="og:type" content="article">
<meta property="og:title" content="智能体四模块现状">
<meta property="og:url" content="https://gaoguodong03.github.io/gdBlog/2026/01/12/%E8%AE%B0%E5%BF%86%EF%BC%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E8%A7%84%E5%88%92%EF%BC%8C%E9%80%89%E5%8F%96%E7%8E%B0%E7%8A%B6/index.html">
<meta property="og:site_name" content="果冻小配方">
<meta property="og:description" content="1. 记忆 (Memory): 从被动存储到主动学习智能体的记忆模块负责信息的持久化存储和高效检索，解决了大型语言模型（LLM）本身“无状态”、“健忘”的核心问题。  早期状态 (2023-2024): 主要依赖RAG (Retrieval-Augmented Generation)。通过将外部知识（文档、数据库）转换为向量，并存储在向量数据库（如Pinecone, Chroma）中。当用户提问时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gaoguodong03.github.io/gdBlog/img/logoZiyouzhiyi.jpg">
<meta property="article:published_time" content="2026-01-11T16:00:00.000Z">
<meta property="article:modified_time" content="2026-01-12T14:05:53.491Z">
<meta property="article:author" content="GuoDong">
<meta property="article:tag" content="Agent">
<meta property="article:tag" content="ContextEngineering">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="RAG">
<meta property="article:tag" content="tools">
<meta property="article:tag" content="调研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gaoguodong03.github.io/gdBlog/img/logoZiyouzhiyi.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "智能体四模块现状",
  "url": "https://gaoguodong03.github.io/gdBlog/2026/01/12/%E8%AE%B0%E5%BF%86%EF%BC%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E8%A7%84%E5%88%92%EF%BC%8C%E9%80%89%E5%8F%96%E7%8E%B0%E7%8A%B6/",
  "image": "https://gaoguodong03.github.io/gdBlog/img/logoZiyouzhiyi.jpg",
  "datePublished": "2026-01-11T16:00:00.000Z",
  "dateModified": "2026-01-12T14:05:53.491Z",
  "author": [
    {
      "@type": "Person",
      "name": "GuoDong",
      "url": "https://gaoguodong03.github.io/gdBlog"
    }
  ]
}</script><link rel="shortcut icon" href="/gdBlog/img/logo.jpg"><link rel="canonical" href="https://gaoguodong03.github.io/gdBlog/2026/01/12/%E8%AE%B0%E5%BF%86%EF%BC%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E8%A7%84%E5%88%92%EF%BC%8C%E9%80%89%E5%8F%96%E7%8E%B0%E7%8A%B6/index.html"><link rel="preconnect"/><link rel="stylesheet" href="/gdBlog/css/index.css"><link rel="stylesheet" href="/gdBlog/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/gdBlog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: '/gdBlog/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '智能体四模块现状',
  isHighlightShrink: true,
  isToc: true,
  pageType: 'post'
}</script><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><!-- hexo injector head_end start --><link rel="stylesheet" href="/gdBlog/./css/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.0.0"></head><body><div id="web_bg" style="background-image: url(/gdBlog/img/bg1.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/gdBlog/img/touxiang.jpg" onerror="this.onerror=null;this.src='/gdBlog/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/gdBlog/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/gdBlog/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/gdBlog/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/gdBlog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/link/"><i class="fa-fw fas fa-link"></i><span> 书签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/gdBlog/./img/logoZiyouzhiyi.jpg);"><nav id="nav"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/gdBlog/"><img class="site-icon" src="/gdBlog/img/logo.jpg" alt="Logo"><span class="site-name">果冻小配方</span></a><a class="nav-page-title" href="/gdBlog/"><span class="site-name">智能体四模块现状</span></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 搜索按钮--><!-- 菜单项--><div class="menus_items"><div class="menus_item"><a class="site-page" href="/gdBlog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gdBlog/link/"><i class="fa-fw fas fa-link"></i><span> 书签</span></a></div></div></div><!-- 移动端汉堡菜单按钮（保持原位置）--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">智能体四模块现状</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-11T16:00:00.000Z" title="发表于 2026-01-12 00:00:00">2026-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-12T14:05:53.491Z" title="更新于 2026-01-12 22:05:53">2026-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/gdBlog/categories/%E6%9E%9C%E5%86%BB%E7%9A%84%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/">果冻的理论学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="1-记忆-Memory-从被动存储到主动学习"><a href="#1-记忆-Memory-从被动存储到主动学习" class="headerlink" title="1. 记忆 (Memory): 从被动存储到主动学习"></a>1. 记忆 (Memory): 从被动存储到主动学习</h3><p>智能体的记忆模块负责信息的持久化存储和高效检索，解决了大型语言模型（LLM）本身“无状态”、“健忘”的核心问题。</p>
<ul>
<li><p><strong>早期状态 (2023-2024):</strong> 主要依赖<strong>RAG (Retrieval-Augmented Generation)</strong>。通过将外部知识（文档、数据库）转换为向量，并存储在向量数据库（如Pinecone, Chroma）中。当用户提问时，系统检索最相关的文本片段，并将其作为“短期记忆”喂给LLM。这是一种相对被动的“开卷考试”。</p>
</li>
<li><p><strong>最新进展 (2025-2026):</strong></p>
<ol>
<li><strong>主动记忆管理 (Active Memory Curation):</strong> Agent不再只是被动检索。它能够<strong>自主决定什么信息值得被记住</strong>、什么信息应该被遗忘或归档。例如，在一次复杂的任务后，Agent 会生成一个“任务总结”或“经验教训”，并将其结构化地存入长期记忆中，而不是存储原始的、冗长的对话记录。</li>
<li><strong>分层与混合记忆 (Hierarchical &amp; Hybrid Memory):</strong> Agent的记忆系统变得更加复杂，模拟人脑结构。<ul>
<li><strong>感觉记忆 (Sensory Memory):</strong> 原始的、未经处理的输入流。</li>
<li><strong>短期&#x2F;工作记忆 (Short-term&#x2F;Working Memory):</strong> 也就是下文会提到的上下文窗口，用于当前任务。</li>
<li><strong>长期记忆 (Long-term Memory):</strong> 融合了多种形式：<ul>
<li><strong>情节记忆 (Episodic):</strong> 对话历史、事件序列（“我上次为用户A做了什么？”）。</li>
<li><strong>语义记忆 (Semantic):</strong> 事实、知识、提取的规则（“我知道Python的requests库可以发API请求”）。这部分越来越多地使用**知识图谱（Knowledge Graphs）**与向量数据库结合，实现更精确、可解释的检索。</li>
</ul>
</li>
</ul>
</li>
<li><strong>记忆的自我更新与演化:</strong> Agent能够根据新的信息和反馈来<strong>更新或修正其长期记忆</strong>。如果一个之前存储的“事实”被证明是错误的，系统可以标记甚至修改它。这使得Agent具备了初步的“学习”和“成长”能力。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-上下文-Context-从“长”到“无限”且高效"><a href="#2-上下文-Context-从“长”到“无限”且高效" class="headerlink" title="2. 上下文 (Context): 从“长”到“无限”且高效"></a>2. 上下文 (Context): 从“长”到“无限”且高效</h3><p>上下文窗口是Agent的“工作台”或“RAM”，决定了它在单次交互中能同时处理多少信息。</p>
<ul>
<li><p><strong>早期状态 (2024):</strong> 各大模型厂商展开“军备竞赛”，上下文窗口从128K tokens增长到1M（如Gemini 1.5 Pro），甚至更长。主要解决了“大海捞针”（Needle in a Haystack）的召回能力问题，证明了模型在极长文本中定位信息的能力。</p>
</li>
<li><p><strong>最新进展 (2025-2026):</strong></p>
<ol>
<li><strong>“有效无限”上下文 (Effectively Infinite Context):</strong> 通过<strong>Ring Attention、Infini-Attention</strong>等流式处理技术，模型在理论上可以处理无限长的输入流，而无需将所有内容一次性加载到内存中。这对于处理实时数据流（如服务器日志、视频流分析）是革命性的。虽然仍有性能瓶颈，但“固定窗口大小”的概念正在被打破。</li>
<li><strong>上下文效率的大幅提升:</strong> 核心挑战从“长度”转向“效率”。模型不再盲目依赖整个上下文，而是通过更智能的注意力机制，<strong>自动识别并聚焦于当前步骤最相关的“上下文片段”</strong>。这显著降低了处理长上下文时的推理成本和延迟。</li>
<li><strong>原生多模态上下文 (Natively Multimodal Context):</strong> 上下文窗口不再局限于文本。现在，一个Agent的“工作台”上可以同时摆放<strong>文本、图片、音频片段、短视频、代码块和表格数据</strong>。Agent能够跨模态进行理解和推理，例如“根据这张系统架构图（图片）和这份实时错误日志（文本），找出问题的根本原因”。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-规划-Planning-从线性思维到复杂策略"><a href="#3-规划-Planning-从线性思维到复杂策略" class="headerlink" title="3. 规划 (Planning): 从线性思维到复杂策略"></a>3. 规划 (Planning): 从线性思维到复杂策略</h3><p>规划是Agent的“大脑皮层”，负责将一个复杂的目标分解成一系列可执行的步骤。</p>
<ul>
<li><p><strong>早期状态 (2023-2024):</strong></p>
<ul>
<li><strong>Chain-of-Thought (CoT):</strong> 简单的线性思考链。</li>
<li><strong>ReAct (Reason + Act):</strong> 在思考和行动之间交替，引入了工具使用的基本循环。</li>
<li><strong>Tree-of-Thought (ToT):</strong> 探索多个不同的推理路径，形成一棵思维树，并从中选择最优解。</li>
</ul>
</li>
<li><p><strong>最新进展 (2025-2026):</strong></p>
<ol>
<li><strong>动态与自适应规划 (Dynamic &amp; Adaptive Planning):</strong> Agent的规划不再是静态的“一次性产品”。它会生成一个初步计划，但在执行每一步后，会根据<strong>反馈（Feedback）和环境变化（Observation）<strong>来</strong>动态修正、甚至完全重构</strong>后续的计划。例如，如果一个API调用失败，Agent不会简单地重试，而是会分析失败原因，并可能决定更换工具或采用替代方案。</li>
<li><strong>层级规划 (Hierarchical Planning):</strong> 面对极其复杂的任务（如“帮我规划并预订一次为期一周的欧洲家庭旅行”），Agent会先生成一个高层级的宏观计划（选择国家 -&gt; 订机票酒店 -&gt; 规划每日行程），然后针对每一个宏观步骤，再生成具体的、可执行的微观计划（查询航班 -&gt; 比较价格 -&gt; 调用预订API）。</li>
<li><strong>多Agent协同规划 (Multi-Agent Collaborative Planning):</strong> 任务规划不再由单一Agent完成。一个“主Agent”（Manager Agent）会把任务分解，并分配给多个<strong>专家Agent</strong>（如“旅行规划Agent”、“代码编写Agent”、“数据分析Agent”）。它们之间通过通信协议协同工作、互相评审（Review），最终汇总成果。这种模式极大地提升了解决复杂问题的鲁棒性和专业性。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-Agent-工具选取-Agent-Tool-Selection-从简单调用到自主创造"><a href="#4-Agent-工具选取-Agent-Tool-Selection-从简单调用到自主创造" class="headerlink" title="4. Agent&#x2F;工具选取 (Agent&#x2F;Tool Selection): 从简单调用到自主创造"></a>4. Agent&#x2F;工具选取 (Agent&#x2F;Tool Selection): 从简单调用到自主创造</h3><p>这个模块是Agent与数字世界或物理世界交互的“手和脚”。</p>
<ul>
<li><p><strong>早期状态 (2023-2024):</strong> 主要依赖<strong>函数调用（Function Calling）<strong>或</strong>Tool Use API</strong>。开发者需要预先定义好一套工具（API），并提供详细的描述，LLM根据用户意图选择调用。</p>
</li>
<li><p><strong>最新进展 (2025-2026):</strong></p>
<ol>
<li><strong>自主工具发现与学习 (Autonomous Tool Discovery &amp; Learning):</strong> Agent不再局限于预定义的工具库。它可以<strong>通过阅读API文档、GitHub仓库甚至自然语言描述，来学习如何使用一个全新的工具</strong>。这个过程被称为“Tool Learning”。</li>
<li><strong>工具创造 (Tool Making):</strong> 这是最令人兴奋的进展之一。当Agent发现现有工具无法满足任务需求时，它能够<strong>自己编写、调试并使用新的、简单的工具</strong>（通常是Python脚本）。例如，如果缺少一个计算汇率的工具，Agent可以自己写一个调用公开汇率API的Python函数，并将其加入自己的临时工具箱。</li>
<li><strong>多工具组合与链式调用 (Multi-Tool Composition &amp; Chaining):</strong> Agent能在一个步骤中<strong>智能地组合多个工具</strong>。它不再是“调用工具A，然后用结果调用工具B”，而是能生成复杂的调用逻辑，例如“先调用搜索工具获取数据，然后用代码解释器工具对数据进行清洗和分析，最后用绘图工具生成图表”。</li>
</ol>
</li>
</ul>
<h3 id="Agent-工具选取-Agent-Tool-Selection-Making-最推荐"><a href="#Agent-工具选取-Agent-Tool-Selection-Making-最推荐" class="headerlink" title="Agent&#x2F;工具选取 (Agent&#x2F;Tool Selection &amp; Making) - 最推荐"></a>Agent&#x2F;工具选取 (Agent&#x2F;Tool Selection &amp; Making) - 最推荐</h3><p>这个方向是目前Agent领域最“性感”、最容易出成果的方向。因为它直接关系到Agent的行动能力，成果非常直观。</p>
<ul>
<li><p><strong>为什么好写论文？</strong></p>
<ul>
<li><strong>创新点明确</strong>：“让Agent自己创造工具(Tool Making)”或“让Agent自主学习新工具(Tool Learning)”是非常新颖且强大的概念。你不需要发明一个全新的LLM，只需要设计一个巧妙的框架。</li>
<li><strong>实验可控且可量化</strong>：你可以设计一系列任务，对比你的Agent（能创造工具）和基线Agent（只能使用预定义工具）的成功率、效率、解决问题的泛化能力。</li>
<li><strong>成果直观</strong>：你可以直接展示出Agent为了解决一个问题而自主编写并执行的Python代码，这是非常有说服力的。</li>
<li><strong>技术栈成熟</strong>：可以基于现有开源框架（如LangChain, LlamaIndex, CrewAI）进行二次开发，专注于你的核心创新逻辑。</li>
</ul>
</li>
<li><p><strong>可能的论文题目&#x2F;研究方向：</strong></p>
<ol>
<li><strong>《The Emergent Toolmaker: An Agent that Writes its Own Code to Solve Novel Problems》</strong> (涌现的工具创造者：一个通过编写代码解决新问题的智能体)<ul>
<li><strong>核心思想</strong>：当Agent面对一个没有现成工具可用的任务时，它会分析任务需求，打开一个代码解释器，编写一个Python函数（例如，一个调用特定API的函数），然后将这个新函数加入其临时工具库并使用它。</li>
</ul>
</li>
<li><strong>《Read the Docs: Autonomous Tool Acquisition from Unstructured API Documentation》</strong> (阅读文档：从非结构化API文档中自主学习工具)<ul>
<li><strong>核心思想</strong>：给Agent一个API文档的URL，让它自己阅读、理解、并生成符合规范的函数调用（Function Calling）JSON Schema，从而学会使用这个新API。</li>
</ul>
</li>
<li><strong>《Tool Smarter, Not Harder: Adaptive Tool Selection via Reflective Feedback》</strong> (更聪明地使用工具：通过反思反馈进行自适应工具选择)<ul>
<li><strong>核心思想</strong>：当工具调用失败时，Agent不只是简单重试，而是会“反思”失败的原因（如API密钥错误、参数无效），然后修正自己的行为或选择替代工具。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Part-1-必读的核心论文（奠基石与范式）"><a href="#Part-1-必读的核心论文（奠基石与范式）" class="headerlink" title="Part 1: 必读的核心论文（奠基石与范式）"></a>Part 1: 必读的核心论文（奠基石与范式）</h3><p>这些论文定义了Agent如何使用工具的基本范式，是你开展任何项目前都应该理解的。</p>
<ol>
<li><p><strong>ReAct: Synergizing Reasoning and Acting in Language Models (2022)</strong></p>
<ul>
<li><strong>下载链接:</strong> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2210.03629">https://arxiv.org/abs/2210.03629</a></li>
<li><strong>核心思想 (必读中的必读):</strong> ReAct 提出了一个极其经典的循环：<strong>Thought (思考) -&gt; Action (行动) -&gt; Observation (观察)</strong>。LLM不再是一次性输出答案，而是先思考“我下一步该做什么？”，然后决定调用一个工具（如搜索），得到结果（观察），再基于新结果进行下一步思考。这是几乎所有现代Agent框架的底层逻辑。</li>
<li><strong>为什么重要:</strong> 让你理解Agent“思考-行动”循环的本质。</li>
</ul>
</li>
<li><p><strong>ToolFormer: Language Models That Teach Themselves to Use Tools (2023)</strong></p>
<ul>
<li><strong>下载链接:</strong> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2302.04761">https://arxiv.org/abs/2302.04761</a></li>
<li><strong>核心思想:</strong> Meta AI的重磅研究。它展示了如何让一个LLM<strong>在“预训练”阶段就自己学会使用工具</strong>。它通过生成大量的API调用候选，然后执行它们，看执行结果能否帮助模型更好地预测未来文本，如果可以，就将这个API调用标记为正样本，并用它来微调模型。</li>
<li><strong>为什么重要:</strong> 证明了LLM有能力自主学习何时、何地以及如何调用API。虽然复现成本极高，但其“自学”思想是后续很多研究的灵感来源。</li>
</ul>
</li>
<li><p><strong>Gorilla: Large Language Model Connected with Massive APIs (2023)</strong></p>
<ul>
<li><strong>下载链接:</strong> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2305.15334">https://arxiv.org/abs/2305.15334</a></li>
<li><strong>核心思想:</strong> 这篇论文关注于“当有成千上万个API时，模型如何正确选择？”。它发布了一个包含1600+真实API调用的数据集，并微调LLaMA模型来专门处理API调用任务，证明了微调可以显著提升模型在工具选择上的准确性，甚至超越当时的GPT-4。</li>
<li><strong>为什么重要:</strong> 提出了工具选择的**评测基准（Benchmark）**问题，并将“工具选择”作为一个专门的任务来优化。</li>
</ul>
</li>
<li><p><strong>ToolLLM: Facilitating Large Language Models to Master 16000+ Real-world APIs (2023)</strong></p>
<ul>
<li><strong>下载链接:</strong> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2307.16789">https://arxiv.org/abs/2307.16789</a></li>
<li><strong>核心思想:</strong> Gorilla的“威力加强版”。它构建了一个更大、更全面的工具使用数据集（ToolBench），并提出了一套高效的评测框架。最关键的是，它通过精细的**决策树（Decision Tree）**来展示模型的工具选择路径，让Agent的决策过程变得可解释。</li>
<li><strong>为什么重要:</strong> 为大规模、多步骤的复杂工具调用提供了目前最先进的解决方案和评测方法。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Part-2-前沿的创新论文（工具学习与创造）"><a href="#Part-2-前沿的创新论文（工具学习与创造）" class="headerlink" title="Part 2: 前沿的创新论文（工具学习与创造）"></a>Part 2: 前沿的创新论文（工具学习与创造）</h3><p>这些论文代表了最新的研究方向，是寻找项目灵感的绝佳来源。</p>
<ol>
<li><p><strong>CREATOR: Tool Creation for Methodical Long-Term Reasoning (2024)</strong></p>
<ul>
<li><strong>下载链接:</strong> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2401.10164">https://arxiv.org/abs/2401.10164</a></li>
<li><strong>核心思想 (强烈推荐):</strong> 这就是我们之前讨论的**“工具创造”（Tool Making）<strong>的开创性工作。当面对一个新任务时，Agent会先</strong>规划（Plan）<strong>，然后</strong>生成一个Python工具（Create Tool）<strong>来解决其中某个子问题，最后再</strong>执行这个新工具（Execute）**。</li>
<li><strong>为什么重要:</strong> 它将Agent的能力从“使用现有工具”提升到了“创造新工具”，是通向更强自主性的关键一步。</li>
</ul>
</li>
<li><p><strong>Self-Taught Function-Calling (STF):</strong> A Simple Framework to Teach an LLM to Use Tools</p>
<ul>
<li><strong>核心思想:</strong> 这篇论文提出了一种简单有效的方法，让模型<strong>自己从API文档中学习如何调用工具</strong>。过程分为三步：1. <strong>Generate</strong>: 让模型阅读文档并尝试生成调用。2. <strong>Execute</strong>: 执行调用，并获取成功&#x2F;失败的结果。3. <strong>Consolidate</strong>: 将成功的调用案例整理成微调数据，用来训练模型。</li>
<li><strong>为什么重要:</strong> 提供了一个低成本、可复现的“工具学习”方案，你不需要像ToolFormer那样进行复杂的预训练。</li>
</ul>
</li>
<li><p><strong>Rest: Retrieval-based Error Synthesis and Correction for Tool-using LLMs (2024)</strong></p>
<ul>
<li><strong>下载链接:</strong> <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2401.07557">https://arxiv.org/abs/2401.07557</a></li>
<li><strong>核心思想:</strong> 解决了Agent使用工具时一个非常实际的问题：<strong>调用失败了怎么办？</strong>。它提出了一套“反思-纠错”机制。当API调用出错时，Agent会检索相似的错误案例和修正方法，然后根据这些信息来修正自己的下一次调用。</li>
<li><strong>为什么重要:</strong> 极大地提升了Agent在真实世界中使用工具的鲁棒性（Robustness）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Part-3-可行的项目思路（从易到难）"><a href="#Part-3-可行的项目思路（从易到难）" class="headerlink" title="Part 3: 可行的项目思路（从易到难）"></a>Part 3: 可行的项目思路（从易到难）</h3><p>你可以直接从这里选择一个方向，并基于上面的论文进行实现。</p>
<h4 id="项目1-微型“工具创造者”-Mini-Toolmaker"><a href="#项目1-微型“工具创造者”-Mini-Toolmaker" class="headerlink" title="项目1: 微型“工具创造者” (Mini-Toolmaker)"></a>项目1: 微型“工具创造者” (Mini-Toolmaker)</h4><ul>
<li><strong>灵感来源:</strong> <strong>CREATOR</strong></li>
<li><strong>项目描述:</strong> 创建一个Agent，当面对一个没有现成工具的任务时，它能自己编写一个简单的Python函数来完成任务。</li>
<li><strong>实施步骤:</strong><ol>
<li><p><strong>定义任务:</strong> 比如，“计算一个数的阶乘”或“检查一个网站是否在线”。假设你的Agent工具库里没有这些工具。</p>
</li>
<li><p><strong>P1 - 规划与工具生成:</strong> 使用一个强大的LLM（如GPT-4o或Gemini 2.5 Pro），给它Prompt:</p>
<blockquote>
<p>“你的目标是’计算5的阶乘’。你没有任何现成的数学工具。请编写一个名为 <code>calculate_factorial(n)</code> 的Python函数作为新工具来解决这个问题。只返回Python代码块。”</p>
</blockquote>
</li>
<li><p><strong>P2 - 工具集成:</strong> 获取LLM返回的Python代码字符串。使用Python的 <code>exec()</code> 函数在一个受控环境中执行这段代码，从而在运行时动态定义 <code>calculate_factorial</code> 函数。</p>
</li>
<li><p><strong>P3 - 工具执行:</strong> 再次调用LLM，并更新你的可用工具列表:</p>
<blockquote>
<p>“你现在有了一个新工具 <code>calculate_factorial(n)</code>。你的目标是’计算5的阶乘’。请生成调用这个工具的指令。”</p>
</blockquote>
</li>
<li><p><strong>验证:</strong> Agent应能成功调用它自己创建的函数并得到结果120。</p>
</li>
</ol>
</li>
<li><strong>创新点:</strong> 实现了一个完整的“构思-&gt;创造-&gt;使用”的闭环。可以写一篇很好的项目报告或论文，展示Agent在新任务上的零样本（zero-shot）解决能力。</li>
</ul>
<h4 id="项目2-“工具纠错大师”-Tool-Error-Corrector"><a href="#项目2-“工具纠错大师”-Tool-Error-Corrector" class="headerlink" title="项目2: “工具纠错大师” (Tool Error Corrector)"></a>项目2: “工具纠错大师” (Tool Error Corrector)</h4><ul>
<li><strong>灵感来源:</strong> <strong>Rest</strong></li>
<li><strong>项目描述:</strong> 创建一个能从工具调用失败中学习和恢复的Agent。</li>
<li><strong>实施步骤:</strong><ol>
<li><p><strong>设置陷阱:</strong> 定义一个API工具，但故意在文档或示例中给一个错误的参数名，例如 <code>search(query)</code>，但实际函数是 <code>search(text)</code>。</p>
</li>
<li><p><strong>P1 - 尝试与失败:</strong> 让Agent尝试调用工具。它会根据错误文档生成 <code>search(query=&quot;...&quot;)</code>，程序执行时会因为 <code>TypeError</code> 而失败。</p>
</li>
<li><p><strong>P2 - 捕获与反思:</strong> 使用 <code>try-except</code> 捕获异常，并将错误信息（e.g., <code>TypeError: search() got an unexpected keyword argument &#39;query&#39;</code>）返回给Agent。</p>
</li>
<li><p><strong>P3 - 纠错:</strong> 给LLM一个新的Prompt:</p>
<blockquote>
<p>“你上次尝试调用<code>search</code>工具失败了，错误信息是’…’。这是工具的正确签名：<code>def search(text: str)</code>。请修正你之前的调用，并重新尝试。”</p>
</blockquote>
</li>
<li><p><strong>验证:</strong> Agent应能生成正确的调用 <code>search(text=&quot;...&quot;)</code> 并成功。</p>
</li>
</ol>
</li>
<li><strong>创新点:</strong> 专注于提升Agent的鲁棒性。可以设计一组常见的API错误类型（参数错误、认证失败等），并量化你的Agent的纠错成功率。</li>
</ul>
<h4 id="项目3-“API文档自学者”-API-Doc-Learner"><a href="#项目3-“API文档自学者”-API-Doc-Learner" class="headerlink" title="项目3: “API文档自学者” (API Doc Learner)"></a>项目3: “API文档自学者” (API Doc Learner)</h4><ul>
<li><strong>灵感来源:</strong> <strong>Self-Taught Function-Calling (STF)</strong></li>
<li><strong>项目描述:</strong> 构建一个Agent，给它一段非结构化的API文档，让它自己学会如何以正确的格式（如OpenAI Function Calling的JSON Schema）调用这个API。</li>
<li><strong>实施步骤:</strong><ol>
<li><p><strong>获取文档:</strong> 找一个简单的公开API文档，比如一个天气查询API或一个笑话API。将文档的关键部分复制为纯文本。</p>
</li>
<li><p><strong>P1 - 生成Schema:</strong> 向LLM提问:</p>
<blockquote>
<p>“你是一个API专家。请阅读以下API文档，并为<code>get_weather</code>功能生成一个符合OpenAI Function Calling格式的JSON Schema。文档如下：[粘贴文档文本]”</p>
</blockquote>
</li>
<li><p><strong>P2 - 验证与使用:</strong> 检查LLM生成的Schema是否正确。然后，在一个新的对话中，给Agent这个Schema，看它能否根据用户“北京今天天气怎么样？”这样的自然语言，正确地生成API调用。</p>
</li>
</ol>
</li>
<li><strong>创新点:</strong> 聚焦于Agent从自然语言到结构化数据的转换能力，这是<strong>Tool Learning</strong>的核心环节。可以评测Agent在不同复杂度的文档上的学习效果。</li>
</ul>
<p><strong>建议:</strong> 从<strong>项目1或2</strong>开始，它们的核心逻辑清晰，实现相对直接，且成果非常直观，是开始Agent研究的绝佳选择。祝你项目顺利！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://gaoguodong03.github.io/gdBlog">GuoDong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://gaoguodong03.github.io/gdBlog/2026/01/12/%E8%AE%B0%E5%BF%86%EF%BC%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E8%A7%84%E5%88%92%EF%BC%8C%E9%80%89%E5%8F%96%E7%8E%B0%E7%8A%B6/">https://gaoguodong03.github.io/gdBlog/2026/01/12/%E8%AE%B0%E5%BF%86%EF%BC%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8C%E8%A7%84%E5%88%92%EF%BC%8C%E9%80%89%E5%8F%96%E7%8E%B0%E7%8A%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://gaoguodong03.github.io/gdBlog" target="_blank">果冻小配方</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/gdBlog/tags/%E8%B0%83%E7%A0%94/">调研</a><a class="post-meta__tags" href="/gdBlog/tags/LLM/">LLM</a><a class="post-meta__tags" href="/gdBlog/tags/Agent/">Agent</a><a class="post-meta__tags" href="/gdBlog/tags/tools/">tools</a><a class="post-meta__tags" href="/gdBlog/tags/RAG/">RAG</a><a class="post-meta__tags" href="/gdBlog/tags/ContextEngineering/">ContextEngineering</a></div><div class="post-share"><div class="social-share" data-image="/gdBlog/./img/logoZiyouzhiyi.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/gdBlog/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/gdBlog/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/gdBlog/2026/01/13/AGI-NEXT-%E5%B3%B0%E4%BC%9A/" title="AGI-NEXT 峰会"><img class="cover" src="/gdBlog/./img/logoLLM.png" onerror="onerror=null;src='/gdBlog/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">AGI-NEXT 峰会</div></div><div class="info-2"><div class="info-item-1">Q1: 为什么说Chat时代已经结束？ 经过一年的观察，唐杰认为单纯做Chat已经不是在真正解决问题。他原本预判大模型会替代搜索，但现实是谷歌反而用AI把自己的搜索革命了。而2025年初DeepSeek的出现，在他看来彻底终结了Chat范式的竞争。 “可能对研究界、产业界，甚至对很多人都是’横空出世’。”唐杰说，“在DeepSeek这种范式下，Chat时代基本上算是解决了。我们做得再好，也许跟DeepSeek差不多，或许在上面再个性化一点、变成有情感的Chat。但总的来讲，这个范式基本到头了，剩下更多是工程和技术问题。” 这个判断促使智谱做出战略转向。团队内部争论了很多个晚上，最终决定把所有精力放在Coding和Agent上。2025年7月，智谱发布4.5版本，把Coding、Agentic、Reasoning能力整合在一起。 但真实世界的反馈很快给了他们一记重击。 用户拿着模型去编”植物大战僵尸”，结果编不出来。”真实编程环境下有大量问题需要解决。”唐杰说。团队通过RLVR（可验证强化学习）配合编程环境作为反馈，才把效果提升上去。这个经历让他意识到：跑分是跑分，真正让能力进入主...</div></div></div></a><a class="pagination-related" href="/gdBlog/2026/01/12/Skills/" title="有了 MCP，为什么Claude 还要推出 Skills？"><img class="cover" src="/gdBlog/./img/logoLLM.png" onerror="onerror=null;src='/gdBlog/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">有了 MCP，为什么Claude 还要推出 Skills？</div></div><div class="info-2"><div class="info-item-1"> ## Skills 是什么？  要想知道区别，先要知道是什么。 根据官方介绍，Claude 的 Skills 是一种模块化的能力包，它以文件夹的形式组织， 每个 Skill 包含：  一个 **SKILL.md** 文件——描述该技能的详细用途和操作流程  脚本与模板——自动化执行复杂任务，比如处理 Excel、生成 PowerPoint，或遵循品牌规范等。  资源文件——辅助技能运行的必要材料（如代码片段、流程文档等）。   ![[ObsidianPicture&#x2F;Pasted image 20260112094242.png]]Claude 只会在需要时，动态加载对应的 Skills。 类似于给 AI 助手装上专业“技能包”，以便完成一些特定的复杂工作。 Skills 与 MCP 的区别用人类可以理解的话来说： Skills 主要聚焦于工具处理。 例如处理文件、设计、写文章。  MCP 主要起到连接作用。 适合深度集成外部系统，自定义上传、下载、推送等流程。[[MCP(Model Context Protocol模型上下文协议)]]   Skills 与 MCP 并...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/gdBlog/2026/01/13/AGI-NEXT-%E5%B3%B0%E4%BC%9A/" title="AGI-NEXT 峰会"><img class="cover" src="/gdBlog/./img/logoLLM.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-13</div><div class="info-item-2">AGI-NEXT 峰会</div></div><div class="info-2"><div class="info-item-1">Q1: 为什么说Chat时代已经结束？ 经过一年的观察，唐杰认为单纯做Chat已经不是在真正解决问题。他原本预判大模型会替代搜索，但现实是谷歌反而用AI把自己的搜索革命了。而2025年初DeepSeek的出现，在他看来彻底终结了Chat范式的竞争。 “可能对研究界、产业界，甚至对很多人都是’横空出世’。”唐杰说，“在DeepSeek这种范式下，Chat时代基本上算是解决了。我们做得再好，也许跟DeepSeek差不多，或许在上面再个性化一点、变成有情感的Chat。但总的来讲，这个范式基本到头了，剩下更多是工程和技术问题。” 这个判断促使智谱做出战略转向。团队内部争论了很多个晚上，最终决定把所有精力放在Coding和Agent上。2025年7月，智谱发布4.5版本，把Coding、Agentic、Reasoning能力整合在一起。 但真实世界的反馈很快给了他们一记重击。 用户拿着模型去编”植物大战僵尸”，结果编不出来。”真实编程环境下有大量问题需要解决。”唐杰说。团队通过RLVR（可验证强化学习）配合编程环境作为反馈，才把效果提升上去。这个经历让他意识到：跑分是跑分，真正让能力进入主...</div></div></div></a><a class="pagination-related" href="/gdBlog/2025/10/11/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B-Context-Engineering/" title="上下文工程(Context Engineering)"><img class="cover" src="/gdBlog/./img/logoZiyouzhiyi.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-11</div><div class="info-item-2">上下文工程(Context Engineering)</div></div><div class="info-2"><div class="info-item-1">前言随着大模型能力的快速发展，人们对大语言模型的使用方式越来越多的从简单的ChatBot，变成了各种Agent，而一个新的术语——上下文工程（Context Engineering），也逐步取代了[[提示工程]](Prompt Engineering）。 最近[Anthropic]发表了一篇文章，分享了他们在上下文工程上的探索，本文基于原文做了适当解读。 上下文工程和提示工程的区别—记忆简单来说，提示工程重点关注的是为了获得最佳结果而编写和组织的LLM指令的方法，各种在公众号、B站、小红书上所介绍的如何在某一款软件中输入特定的指令从而能够获得某种效果的方法，都属于提示工程，它通常涉及需要完成的任务、任务的背景信息、如何更好的完成任务、哪些是禁止的、受众是谁等，例如如何使用AI写文章、如何去除AI味、如何使用豆包生成特定的图片等。 而上下文工程指的是，在LLM推理过程中，如何管理和维护要输入给LLM的最佳信息的策略集，之所以叫信息，而没有叫Prompt或者提示语，是因为在上下文工程中，除了涉及给LLM安排任务，还涉及到工具、当前任务所需要的参考资料、之前交互过程中的记忆等，参考资料...</div></div></div></a><a class="pagination-related" href="/gdBlog/2025/10/11/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%8D%8F%E5%90%8C%E6%9E%B6%E6%9E%84%E8%B0%83%E7%A0%94/" title="多智能体协同架构调研"><img class="cover" src="/gdBlog/./img/logoZiyouzhiyi.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-11</div><div class="info-item-2">多智能体协同架构调研</div></div><div class="info-2"><div class="info-item-1">上下文工程 任务管理者 依次往总线扔任务 会议时间文档链接：https://free4inno.feishu.cn/wiki/CxV0wuVATi8Z0hk6wF8cWgzCnTb报告时间：2025&#x2F;10&#x2F;10报告人：孟千斌 简要记录调研了多种多智能体协同架构，包括 OpenManus、微软开源的 AutoGen、字节开源的 LongManus（基于 LongGraph）等，并对它们进行了横向对比  OpenManus：因闭源，分析基于官网 Blog 及演示视频，聚焦其多智能体协同模式，单智能体模式未涉及。 AutoGen：提供 5 种多智能体协同解法： 双智能体聊天（带函数调用）：由用户代理和助手构成，通过交替对话、任务拆分函数调用逐步完成任务，支持人工在关键节点介入。 群聊（Group chat）：预设多角色智能体与群聊管理器，管理器根据上下文和角色能力自动路由任务，公共历史记录信息，支持发布 &#x2F; 订阅模式优化。 AutoBuild：能从自然语言需求出发，自动生成带角色定位的智能体并组成群聊，经协作完成任务后反思总结并返回结果。 Mixture ...</div></div></div></a><a class="pagination-related" href="/gdBlog/2026/01/13/%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96/" title="工具选取"><img class="cover" src="/gdBlog/./img/logoLLM.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-13</div><div class="info-item-2">工具选取</div></div><div class="info-2"><div class="info-item-1">1. AutoTool: 高效工具选择框架（2025年11月）论文信息：《AutoTool: Efficient Tool Selection for Large Language Model Agents》（已被 AAAI 2026 录用）arxiv​ 核心创新：该论文指出，当前 ReAct 等框架存在的主要瓶颈是工具选择的高推理成本。作者提出了基于图的 AutoTool 框架，核心观察是工具使用惯性（tool usage inertia）——即工具调用往往遵循可预测的顺序模式。 技术方案：  从历史智能体轨迹构建有向图，节点代表工具，边的权重代表转移概率  通过图遍历进行工具选择，最小化 LLM 推理  集成参数级信息优化工具输入生成  不仅处理工具名称，还处理参数值   实验结果：  推理成本降低 30%，同时保持竞争力的任务完成率  在多个智能体任务上验证有效性   实验进度：评估脚本已可正常运行，但 API 调用存在超时问题，可能需要：  检查 API 配置（base_url 和模型名称）  增加超时时间设置  检查网络连接   本次会话总结2. 修复了多个代码问题pa...</div></div></div></a><a class="pagination-related" href="/gdBlog/2025/10/01/RAG%EF%BC%88Retrieval-AugmentedGeneration%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90%EF%BC%89/" title="RAG（Retrieval-AugmentedGeneration检索增强生成）"><img class="cover" src="/gdBlog/./img/logoZiyouzhiyi.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-01</div><div class="info-item-2">RAG（Retrieval-AugmentedGeneration检索增强生成）</div></div><div class="info-2"><div class="info-item-1">写在前面RAG 是一种新兴的 AI 技术，它结合了信息检索和生成式 AI 的优势，能够在处理复杂任务时提供更准确和相关的答案。RAG 的实现过程相对简单，但是它的核心在于如何检索到相关的信息，以及如何将这些信息与 LLM 结合，这就是 RAG 的关键所在。 LLM的局限性RAG（Retrieval-Augmented Generation 检索增强生成）正如其字面意思，是通过检索信息来增强 LLM生成的能力。RAG 是一种新兴的 AI 技术，它结合了信息检索和生成式 AI 的优势，能够在处理复杂任务时提供更准确和相关的答案。 RAG 的工作原理是：首先通过检索引擎从一个大型知识库中获取相关信息，然后将这些信息通过 Prompt 工程与 LLM 结合，生成最终的答案。 为什么需要这样做呢？ LLM的特点：  会回答你很多不存在的东西，编造一些不存在的事实，或者是对事实进行错误的推理，LLM 回答不存在的东西的现象被称为幻觉（Hallucination）。 尤其不擅长于最新的技术和最近的热点事件（注：这里排除掉能够使用联网能力的产品），因为 LLM 训练时使用的数据集是有截止日期的。...</div></div></div></a><a class="pagination-related" href="/gdBlog/2025/10/03/%E8%81%8A%E8%81%8ADeep-Search-%E5%92%8CDeep-Research/" title="聊聊Deep Search 和Deep Research"><img class="cover" src="/gdBlog/./img/logoDeepsearch.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-03</div><div class="info-item-2">聊聊Deep Search 和Deep Research</div></div><div class="info-2"><div class="info-item-1">2022 年 11 月 30 日，OpenAI 正式发布 ChatGPT 产品，仅两个月后，其月活用户就突破了 1 个亿，成为历史上增长最快的消费类应用之一。一时之间，生成式 AI 技术遍地开花，国内外科技大厂紧锣密鼓纷纷入场，各种大模型和 AI 产品以星火燎原之势涌现出来。 ChatGPT 的发布对传统搜索（如 Google）和问答社区（如 StackOverflow）造成了强烈的冲击。用户对传统搜索的不满早已不是秘密，搜索结果中大量的广告和低质的 SEO 内容导致用户体验很差，而 ChatGPT 通过自然语言以对话的方式为用户直接提供答案，省去了用户在海量的搜索页面之间反复跳转和搜集信息的麻烦。谷歌拥有 DeepMind 和 Google Brain 两大顶尖 AI 实验室，原本有机会站在这波生成式 AI 浪潮的最顶端，但是管理层安于现状，不忍放弃广告业务的利润，最终被 ChatGPT 抢占先机。为了应对 ChatGPT 的冲击，谷歌很快开始了反击，公司在内部发布 红色代码（Red Code） 预警，进入战备状态，创始人布林甚至亲自下场为聊天机器人 Bard 写代码。 生成式...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/gdBlog/img/touxiang.jpg" onerror="this.onerror=null;this.src='/gdBlog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GuoDong</div><div class="author-info-description">碎碎念念 岁岁年年</div><div class="site-data"><a href="/gdBlog/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/gdBlog/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/gdBlog/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://www.douyin.com/" target="_blank" title="douyin"><i class="fab fa-tiktok" style="color: #24292e;"></i></a><a class="social-icon" href="https://www.bilibili.com/" target="_blank" title="bilibili"><i class="fab fa-bilibili" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/gaoguodong03" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://leetcode.cn/studyplan/top-100-liked/" target="_blank" title="LeetCode"><i class="fab fa-comments" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">南京北京 反复横跳</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%B0%E5%BF%86-Memory-%E4%BB%8E%E8%A2%AB%E5%8A%A8%E5%AD%98%E5%82%A8%E5%88%B0%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">1. 记忆 (Memory): 从被动存储到主动学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8A%E4%B8%8B%E6%96%87-Context-%E4%BB%8E%E2%80%9C%E9%95%BF%E2%80%9D%E5%88%B0%E2%80%9C%E6%97%A0%E9%99%90%E2%80%9D%E4%B8%94%E9%AB%98%E6%95%88"><span class="toc-number">2.</span> <span class="toc-text">2. 上下文 (Context): 从“长”到“无限”且高效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%84%E5%88%92-Planning-%E4%BB%8E%E7%BA%BF%E6%80%A7%E6%80%9D%E7%BB%B4%E5%88%B0%E5%A4%8D%E6%9D%82%E7%AD%96%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">3. 规划 (Planning): 从线性思维到复杂策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Agent-%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96-Agent-Tool-Selection-%E4%BB%8E%E7%AE%80%E5%8D%95%E8%B0%83%E7%94%A8%E5%88%B0%E8%87%AA%E4%B8%BB%E5%88%9B%E9%80%A0"><span class="toc-number">4.</span> <span class="toc-text">4. Agent&#x2F;工具选取 (Agent&#x2F;Tool Selection): 从简单调用到自主创造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Agent-%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96-Agent-Tool-Selection-Making-%E6%9C%80%E6%8E%A8%E8%8D%90"><span class="toc-number">5.</span> <span class="toc-text">Agent&#x2F;工具选取 (Agent&#x2F;Tool Selection &amp; Making) - 最推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Part-1-%E5%BF%85%E8%AF%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E8%AE%BA%E6%96%87%EF%BC%88%E5%A5%A0%E5%9F%BA%E7%9F%B3%E4%B8%8E%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">Part 1: 必读的核心论文（奠基石与范式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Part-2-%E5%89%8D%E6%B2%BF%E7%9A%84%E5%88%9B%E6%96%B0%E8%AE%BA%E6%96%87%EF%BC%88%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%9B%E9%80%A0%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">Part 2: 前沿的创新论文（工具学习与创造）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Part-3-%E5%8F%AF%E8%A1%8C%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%B7%AF%EF%BC%88%E4%BB%8E%E6%98%93%E5%88%B0%E9%9A%BE%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">Part 3: 可行的项目思路（从易到难）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE1-%E5%BE%AE%E5%9E%8B%E2%80%9C%E5%B7%A5%E5%85%B7%E5%88%9B%E9%80%A0%E8%80%85%E2%80%9D-Mini-Toolmaker"><span class="toc-number">8.1.</span> <span class="toc-text">项目1: 微型“工具创造者” (Mini-Toolmaker)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE2-%E2%80%9C%E5%B7%A5%E5%85%B7%E7%BA%A0%E9%94%99%E5%A4%A7%E5%B8%88%E2%80%9D-Tool-Error-Corrector"><span class="toc-number">8.2.</span> <span class="toc-text">项目2: “工具纠错大师” (Tool Error Corrector)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE3-%E2%80%9CAPI%E6%96%87%E6%A1%A3%E8%87%AA%E5%AD%A6%E8%80%85%E2%80%9D-API-Doc-Learner"><span class="toc-number">8.3.</span> <span class="toc-text">项目3: “API文档自学者” (API Doc Learner)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/gdBlog/2026/01/13/AGI-NEXT-%E5%B3%B0%E4%BC%9A/" title="AGI-NEXT 峰会">AGI-NEXT 峰会</a><time datetime="2026-01-12T16:00:00.000Z" title="发表于 2026-01-13 00:00:00">2026-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/gdBlog/2026/01/13/%E5%B7%A5%E5%85%B7%E9%80%89%E5%8F%96/" title="工具选取">工具选取</a><time datetime="2026-01-12T16:00:00.000Z" title="发表于 2026-01-13 00:00:00">2026-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/gdBlog/2026/01/12/A2UI/" title="A2UI(Agent to User Interface)">A2UI(Agent to User Interface)</a><time datetime="2026-01-11T16:00:00.000Z" title="发表于 2026-01-12 00:00:00">2026-01-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"></div><div class="footer_custom_text"><style>
  .footer {
    text-align: center;
    position: relative;
  }
  .social-links {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }
  .social-links i {
    color: #000000;
  }
  .social-link {
    color: #000000;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    background: rgba(0, 0, 0, 0.1);
  }
  .social-link:hover {
    color: #333333;
    background: rgba(0, 0, 0, 0.2);
    transform: translateY(-3px) scale(1.2);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    text-decoration: none !important; 
  }
  .footer p {
    margin: 0.5rem 0;
    line-height: 1;
  }
  .copyright {
    font-size: 1.1rem; 
    color: #000000;
    font-weight: 400;
  }
  .tagline {
    font-size: 0.8rem;
    color: #333333;
    font-style: italic;
    font-weight: 500;
  }
  .visitor-count {
    font-size: 0.75rem;
    color: rgba(0, 0, 0, 0.7);
    font-weight: 300;
  }
  #visitorCount {
    font-weight: bold;
  }
</style>
<div class="footer">
  <p class="copyright">© 2025 果冻小配方 - 所有权利保留</p>
  <p class="tagline">> 碎碎念念 岁岁年年 <</p>
  <p class="visitor-count">访问量: <span id="visitorCount">1024</span> | 你是第 <span id="dailyVisitor">1</span> 位今日访客</p>
</div>
<script>
  // 确保DOM加载完成后执行
  document.addEventListener('DOMContentLoaded', function() {
    // 模拟访问量增长
    function updateVisitorCount() {
      const countElement = document.getElementById('visitorCount');
      let count = parseInt(countElement.textContent) || 1024;
      // 从localStorage获取或初始化计数
      const storedCount = localStorage.getItem('totalVisitors');
      if (storedCount) {
        count = parseInt(storedCount);
        countElement.textContent = count;
      }
      // 每日访客计数
      const today = new Date().toDateString();
      const dailyData = JSON.parse(localStorage.getItem('dailyVisitors') || '{"date":"", "count":0}');
      if (dailyData.date !== today) {
        dailyData.date = today;
        dailyData.count = 0;
      }
      dailyData.count += 1;
      document.getElementById('dailyVisitor').textContent = dailyData.count;
      localStorage.setItem('dailyVisitors', JSON.stringify(dailyData));
      // 每30秒随机增加访问量
      setInterval(() => {
        count += Math.floor(Math.random() * 3);
        countElement.textContent = count;
        localStorage.setItem('totalVisitors', count.toString());
      }, 30000);
    }
    updateVisitorCount();
    // 添加点击动画效果
    const socialLinks = document.querySelectorAll('.social-link');
    socialLinks.forEach(link => {
      link.addEventListener('click', function() {
        this.style.transform = 'scale(0.9)';
        setTimeout(() => {
          this.style.transform = '';
        }, 300);
      });
    });
  });
</script>
</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/gdBlog/js/utils.js"></script><script src="/gdBlog/js/main.js"></script><div class="js-pjax"></div><script src="/config/js/happy-title.js" async></script><script src="/config/js/foot.js" async></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_categories_card_injector_config(){
    // 检查容器是否存在
    var parent_div_git = document.getElementById('recent-posts');
    // 如果容器不存在，则动态创建
    if (!parent_div_git) {
      console.warn('butterfly_categories_card: 挂载容器不存在，正在动态创建...');
      // 创建新容器（默认插入到页面主体顶部）
      parent_div_git = document.createElement('div');
      parent_div_git.id = 'recent-posts'; // 赋予配置的ID
      document.querySelector('#page').prepend(parent_div_git); // 插入到 #content-inner 内
    }
    var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 950px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 800px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/img/logo.jpg);"> <a class="categoryBar-list-link" href="/categories/果冻的日记本/">果冻的日记本</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">果冻的航海日记</span></li><li class="categoryBar-list-item" style="background:url(/img/logo.jpg);"> <a class="categoryBar-list-link" href="/categories/果冻的理论学习/">果冻的理论学习</a><span class="categoryBar-list-count">14</span><span class="categoryBar-list-descr">Hexo</span></li><li class="categoryBar-list-item" style="background:url(/img/logo.jpg);"> <a class="categoryBar-list-link" href="/categories/果冻的科普专区/">果冻的科普专区</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr">果冻的奇妙小工具</span></li><li class="categoryBar-list-item" style="background:url(/img/logo.jpg);"> <a class="categoryBar-list-link" href="/categories/果冻的奇妙小工具/">果冻的奇妙小工具</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">果冻的日记本</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="/categories/果冻的航海日志/">果冻的航海日志</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="/categories/Hexo/">Hexo</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="/categories/果冻的LeetCode刷题/">果冻的LeetCode刷题</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
    console.log('已挂载 butterfly_categories_card');
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
  }
  // 路径匹配逻辑（使用 startsWith）
  if (location.pathname.startsWith('/categories/') || '/categories/' === 'all') {
    butterfly_categories_card_injector_config();
  }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '300ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>